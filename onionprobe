#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Onionprobe test/monitor tool.
#
# Copyright (C) 2022 Silvio Rhatto <rhatto@torproject.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Dependencies
import argparse
import os
import time
import random
import io
import shutil
import logging

from datetime import datetime, timedelta

try:
    import stem
    import stem.control
    import stem.process
    import stem.util
except ImportError:
    print("Please install stem library first!")
    raise ImportError

try:
    import yaml
except ImportError:
    print("Please install pyaml first!")
    raise ImportError

try:
    import requests
except ImportError:
    print("Please install requests first!")
    raise ImportError

# Defaults
defaults = {
        'log_level'               : 'info',
        'launch_tor'              : True,
        'tor_address'             : '127.0.0.1',
        'socks_port'              : 19050,
        'control_port'            : 19051,
        'control_password'        : False,
        'loop'                    : False,
        'prometheus_exporter'     : False,
        'prometheus_exporter_port': 9091,
        'shuffle'                 : True,
        'randomize'               : True,
        'new_circuit'             : False,
        'interval'                : 60,
        'sleep'                   : 60,
        'endpoints'               : {
            'www.torproject.org': {
                'address' : '2gzyxa5ihm7nsggfxnu52rck2vv4rvmdlkiu3zzui5du4xyclen53wid.onion',
                'protocol': 'http',
                'port'    : '80',
                'paths'   : [
                        {
                            'path'   : '/',
                            'pattern': 'Tor Project',
                        },
                    ],
                },
            }
        }

class Onionprobe:
    """Test/monitor Tor Onion Services"""

    #
    # Initialization logic
    #

    def __init__(self, args):
        self.args = args
        self.data = []

        # Config file handling
        if args.config is not None:
            if os.path.exists(args.config):
                with open(args.config, 'r') as config:
                    self.config = yaml.load(config, yaml.CLoader)
            else:
                raise FileNotFoundError('No such file ' + args.config)
        else:
            self.config = {}

    def initialize(self):
        """Initialization procedures"""

        # Initializes the random number generator
        random.seed()

        if self.initialize_logging() is False:
            return False

        if self.initialize_tor() is False:
            return False

        if self.initialize_tor_auth() is False:
            return False

        # Stream management
        # See https://stem.torproject.org/tutorials/to_russia_with_love.html
        if self.get_config('new_circuit'):
            self.controller.set_conf('__LeaveStreamsUnattached', '1')
            self.controller.add_event_listener(self.new_circuit, stem.control.EventType.STREAM)
            self.circuit_id = None

        # Prometheus
        if self.get_config('prometheus_exporter'):
            # Enforce continuous run
            self.config['loop'] = True

            if self.initialize_prometheus_exporter() is False:
                return False

        self.initialize_metrics()

    def initialize_logging(self):
        """Initialize logging"""

        log_level = self.get_config('log_level').upper()

        if log_level in dir(logging):
            level = getattr(logging, log_level)

            logging.basicConfig(level=level)

            # See https://stem.torproject.org/api/util/log.html
            stem_logger = stem.util.log.get_logger()

            stem_logger.setLevel(level)

        else:
            logging.error("Invalid log level %s" % (log_level))

            return False

    def initialize_tor(self):
        """Initialize Tor control connection"""

        control_address = self.get_config('tor_address')
        control_port    = self.get_config('control_port')

        # Ensure control_address is an IP address, which is the
        # only type currently supported by stem
        #
        # Right now only IPv4 is supported
        import socket
        control_address = socket.gethostbyname(control_address)

        if self.get_config('launch_tor'):
            if self.launch_tor() is False:
                self.log("Error initializing Tor", "critical")

                return False

        try:
            self.controller = stem.control.Controller.from_port(
                    address=control_address,
                    port=control_port)

        except stem.SocketError as exc:
            self.log("Unable to connect to tor on port 9051: %s" % exc, "critical")

            return False

    def initialize_tor_auth(self):
        """Initialize an authenticated Tor control connection"""

        if 'controller' not in dir(self):
            self.log("Unable to find a Tor control connection", "critical")

            return False

        # Evaluate control password only after we're sure that a Tor
        # process is running in the case that 'launch_tor' is True
        control_password = self.get_config('control_password')

        if control_password is False:
            # First try to authenticate without a password
            try:
                self.controller.authenticate()

            # Then fallback to ask for a password
            except stem.connection.MissingPassword:
                import getpass
                control_password = getpass.getpass("Controller password: ")

                try:
                    self.controller.authenticate(password=control_password)
                except stem.connection.PasswordAuthFailed:
                    self.log("Unable to authenticate, password is incorrect", "critical")

                    return False

        else:
            try:
                self.controller.authenticate(password=control_password)
            except stem.connection.PasswordAuthFailed:
                self.log("Unable to authenticate, password is incorrect", "critical")

                return False

    def initialize_prometheus_exporter(self):
        """Initialize the Prometheus Exporter"""

        from prometheus_client import start_http_server

        port = self.get_config('prometheus_exporter_port')

        self.log('Initializing Prometheus HTTP exporter server at port %s...' % (port))
        start_http_server(port)

    def initialize_metrics(self):
        """Initialize the metrics subsystem"""

        # Use Prometheus metrics even if the exported is not in use
        from prometheus_client import Counter, Gauge

        self.metrics = {
                'onionprobe_wait': Gauge(
                        'onionprobe_wait',
                        'How long onionprobe waited between two probes',
                    ),

                'onion_service_latency': Gauge(
                        'onion_service_latency',
                        'Register Onion Service connection latency',
                        ['name', 'address', 'protocol', 'port', 'path']
                    ),

                'onion_service_reachable': Gauge(
                        'onion_service_reachable',
                        'Register if the Onion Service is reachable',
                        ['name', 'address', 'protocol', 'port', 'path']
                    ),

                'onion_service_status_code': Gauge(
                        'onion_service_status_code',
                        'Register Onion Service connection status code',
                        ['name', 'address', 'protocol', 'port', 'path']
                    ),

                'onion_service_descriptor_latency': Gauge(
                        'onion_service_descriptor_latency',
                        'Register Onion Service latency to get the descriptor',
                        ['name', 'address']
                    ),

                'onion_service_descriptor_reachable': Gauge(
                        'onion_service_descriptor_reachable',
                        'Register if the Onion Service descriptor is available',
                        ['name', 'address']
                    ),
                }

    #
    # Helper methods
    #

    def log(self, message, level='info'):
        """Helper log function"""

        getattr(logging, level)(message)

    def get_config(self, item, default = None):
        """Helper to get config or use default value"""

        if item in self.config:
            return self.config[item]

        # Optionally override the default with an argument provided
        elif default is not None:
            self.config[item] = default

            return default

        return defaults[item]

    def wait(self, value):
        """Helper to wait some time"""

        # Randomize if needed
        if self.get_config('randomize'):
            value = random.random() * value

        # Sleep
        self.log('Waiting {} seconds...'.format(str(round(value))))
        self.metrics['onionprobe_wait'].set(value)
        time.sleep(value)

    def elapsed(self, init_time, verbose):
        elapsed = (datetime.now() - init_time)

        if verbose:
            self.log("Elapsed time: " + str(elapsed))

        return timedelta.total_seconds(elapsed)

    #
    # Main application logic
    #

    def run(self):
        """
        Main application loop

        Checks if should be run indefinitely.
        Then dispatch to a round of probes.
        """

        # Check if should loop
        if self.get_config('loop'):
            while True:
                # Call for a round
                self.round()

                # Then wait
                self.wait(self.get_config('sleep'))

        else:
            # Single pass, only one round
            self.round()

    def round(self):
        """
        Process a round of tests

        Each round is composed of the entire set of the endpoints
        which is optionally shuffled.

        Each probe is then tested.
        """

        # Shuffle the deck
        endpoints = sorted(self.get_config('endpoints'))

        if self.get_config('shuffle'):
            # Reinitializes the random number generator to avoid predictable
            # results if running countinuously for long periods.
            random.seed()

            endpoints = random.sample(endpoints, k=len(endpoints))

        # Probe each endpoint
        for key, endpoint in enumerate(endpoints):
            result = self.probe(endpoint)

            # Wait if not last endpoint
            if key != len(endpoints) - 1:
                self.wait(self.get_config('interval'))

    def probe(self, endpoint):
        """Probe an unique endpoint"""

        self.log("Processing {}...".format(endpoint))

        endpoints = self.get_config('endpoints')
        config    = endpoints[endpoint]

        # Check if the addres is valid
        from stem.util.tor_tools import is_valid_hidden_service_address

        if 'address' not in config:
            self.log('No address set for {}'.format(endpoint), 'error')

            return False

        elif is_valid_hidden_service_address(config['address'][0:-6], 3) is False:
            self.log('Invalid onion service address set for {}: {}'.format(endpoint, config['address']), 'error')

            return False

        # Ensure we always begin with a cleared cache
        # This allows to discover issues with published descriptors
        self.controller.clear_cache()

        # Ensure we use a new circuit every time
        # Needs to close all other circuits?
        # Needs to setup a 'controler' circuit?
        # Replaced by event listener at the initialize() method
        #circuit = self.controller.new_circuit()

        # Get Onion Service descriptor
        descriptor = self.get_descriptor(endpoint, config)

        if descriptor is False:
            self.log('Error getting the descriptor', 'error')

            return False

        # Ensure at least a single path
        if 'paths' not in config:
            config['paths'] = [
                        {
                            'path'   : '/',
                            'pattern': None,
                        },
                    ]

        results = {}

        # Query each path
        for path in config['paths']:
            result = self.query(endpoint, config, path['path'])

            if result is not False:
                # Check for a match
                if path['pattern'] is not None:
                    import re
                    pattern = re.compile(path['pattern'])
                    match   = pattern.search(result.text)

                    self.log('Looking for pattern {}...'.format(path['pattern']))

                    if match is not None:
                        self.log('Match found: "%s"' % (path['pattern']))

                        results[path['path']] = result
                    else:
                        self.log('Match not found: "%s"' % (path['pattern']))

                        results[path['path']] = False

                else:
                    results[path['path']] = result

            else:
                self.log('Error querying {}'.format(config['address']), 'error')

                results[path['path']] = False

        return results

    #
    # Endpoint handling logic
    #

    def build_url(self, config, path = None):
        url = config['address']

        if 'protocol' in config:
            url = config['protocol'] + '://' + url

        if 'port' in config:
            url += ':' + config['port']

        #if 'path' in config:
        #    url += config['path']
        if path is not None:
            url += path

        return url

    def query(self, endpoint, config, path):
        """Fetches endpoint from URL"""

        url = self.build_url(config, path)

        self.log('Querying {}...'.format(url))

        init_time   = datetime.now()
        tor_address = self.get_config('tor_address')
        socks_port  = self.get_config('socks_port')
        proxies     = {
                'http' : 'socks5h://{}:{}'.format(tor_address, socks_port),
                'https': 'socks5h://{}:{}'.format(tor_address, socks_port),
                }

        try:
            result  = requests.get(url, proxies=proxies)
            elapsed = self.elapsed(init_time, True)

            self.metrics['onion_service_latency'].labels(
                        name=endpoint,
                        address=config['address'],
                        protocol=config['protocol'],
                        port=config['port'],
                        path=path,
                    ).set(elapsed)

            self.metrics['onion_service_reachable'].labels(
                        name=endpoint,
                        address=config['address'],
                        protocol=config['protocol'],
                        port=config['port'],
                        path=path,
                    ).set(1)

        except requests.exceptions.RequestException as e:
            self.log(e, 'error')

            self.metrics['onion_service_reachable'].labels(
                        name=endpoint,
                        address=config['address'],
                        protocol=config['protocol'],
                        port=config['port'],
                        path=path,
                    ).set(0)

            return False

        #except requests.RequestException as e:
        #    return False

        #except requests.ConnectionError as e:
        #    return False

        #except requests.HTTPError as e:
        #    return False

        #except requests.ToManyRedirects as e:
        #    return False

        #except requests.ConnectionTimeout as e:
        #    return False

        #except requests.ReadTimeout as e:
        #    return False

        #except requests.Timeout as e:
        #    return False

        else:
            self.log('Status code is {}'.format(result.status_code))

            self.metrics['onion_service_status_code'].labels(
                        name=endpoint,
                        address=config['address'],
                        protocol=config['protocol'],
                        port=config['port'],
                        path=path,
                    ).set(result.status_code)

            return result

    #
    # Tor related logic
    #

    def gen_control_password(self):
        """Generates a random password"""

        import secrets

        return secrets.token_urlsafe(random.randrange(22, 32))

    def hash_password(self, password):
        """Produce a hashed password in the format used by HashedControlPassword"""

        import subprocess

        tor    = shutil.which('tor')
        result = subprocess.check_output([tor, '--hash-password', password], text=True)

        return result

    def launch_tor(self):
        """
        Launch a built-in Tor process

        See https://stem.torproject.org/tutorials/to_russia_with_love.html
            https://stem.torproject.org/api/process.html

        """

        if shutil.which('tor') is None:
            self.log('Cannot find the tor executable. Is it installed?', 'critical')

            return False

        from stem.util import term

        def print_bootstrap_lines(line):
            if "Bootstrapped " in line:
                self.log(term.format(line), 'debug')

        try:
            self.log('Initializing Tor process...')

            tor_address      = self.get_config('tor_address')
            control_password = self.get_config('control_password', self.gen_control_password())
            self.tor         = stem.process.launch_tor_with_config(
                    config = {
                        'SocksPort'            : tor_address + ':' + str(self.get_config('socks_port')),
                        'ControlPort'          : tor_address + ':' + str(self.get_config('control_port')),
                        'HashedControlPassword': self.hash_password(control_password),

                        #'Log'                 : [
                        #    'NOTICE stdout',
                        #    ],
                        },
                        init_msg_handler = print_bootstrap_lines,
                    )

        except OSError as e:
            print(e)
            return False

    def new_circuit(self, stream):
        """Setup a fresh circuit for new streams"""

        self.log('Building new circuit...', 'debug')

        # Remove the old circuit
        if self.circuit_id is not None:
            self.log('Removing old circuit {}...'.format(self.circuit_id), 'debug')
            self.controller.close_circuit(self.circuit_id)

        # Create new circuit
        self.circuit_id = self.controller.new_circuit(await_build=True)

        # See https://stem.torproject.org/tutorials/to_russia_with_love.html
        if stream.status == 'NEW':
            self.log('Setting up new circuit {}...'.format(self.circuit_id), 'debug')
            self.controller.attach_stream(stream.id, self.circuit_id)

    def get_descriptor(self, endpoint, config):
        """Get Onion Service descriptor"""

        self.log('Getting descriptor for {}...'.format(config['address']))

        init_time = datetime.now()

        # Get the descriptor
        try:
            descriptor = self.controller.get_hidden_service_descriptor(config['address'])

        except stem.DescriptorUnavailable as e:
            self.metrics['onion_service_descriptor_reachable'].labels(
                        name=endpoint,
                        address=config['address'],
                    ).set(0)

            return False

        except stem.Timeout as e:
            return False

        except stem.ControllerError as e:
            return False

        except ValueError as e:
            return False

        # Ensure it's converted to the v3 format
        #
        # See https://github.com/torproject/stem/issues/96
        #     https://stem.torproject.org/api/control.html#stem.control.Controller.get_hidden_service_descriptor
        #     https://gitlab.torproject.org/legacy/trac/-/issues/25417
        from stem.descriptor.hidden_service import HiddenServiceDescriptorV3
        descriptor = HiddenServiceDescriptorV3.from_str(str(descriptor))

        # Decrypt the inner layer
        inner = descriptor.decrypt(config['address'])

        # Get introduction points
        # See https://stem.torproject.org/api/descriptor/hidden_service.html#stem.descriptor.hidden_service.IntroductionPointV3
        #for introduction_point in inner.introduction_points:
        #    self.log(introduction_point.link_specifiers, 'debug')

        elapsed = self.elapsed(init_time, True)

        self.metrics['onion_service_descriptor_latency'].labels(
                    name=endpoint,
                    address=config['address'],
                ).set(elapsed)

        self.metrics['onion_service_descriptor_reachable'].labels(
                    name=endpoint,
                    address=config['address'],
                ).set(1)

        # Return the inner layer
        return inner

    #
    # Cleansing methods
    #

    def close(self):
        self.controller.close()

        # Terminate built-in Tor
        if 'tor' in dir(self):
            self.tor.kill()

if __name__ == "__main__":
    """Process from CLI"""

    epilog = """Examples:

      onionprobe -c config.yaml
    """

    description = 'Test and monitor onion services'
    parser      = argparse.ArgumentParser(
                    description=description,
                    epilog=epilog,
                    formatter_class=argparse.RawDescriptionHelpFormatter,
                  )

    parser.add_argument('-c', '--config', help='Read options from configuration file')

    args = parser.parse_args()

    # Dispatch
    try:
        probe = Onionprobe(args)

        if probe.initialize() is not False:
            probe.run()
            probe.close()
        else:
            print('Error: could not initialize')
            exit(1)

    except (FileNotFoundError, KeyboardInterrupt) as e:
        print(e)
        exit(1)
